import { aerodynamicForce } from './aerodynamics'
import { TrebuchetPhase } from './types'
import type {
  PhysicsDerivative17DOF,
  PhysicsState17DOF,
  ProjectileProperties,
  TrebuchetProperties,
} from './types'

export type { DerivativeFunction } from './types'

interface TrebuchetGeometry {
  armTipX: number
  armTipY: number
  slingAngle: number
  projRelX: number
  projRelY: number
  distToArmTip: number
}

function computeGeometry(
  state: PhysicsState17DOF,
  trebuchetProps: TrebuchetProperties,
): TrebuchetGeometry {
  const { armAngle } = state
  const { longArmLength, pivotHeight } = trebuchetProps

  const armTipX = longArmLength * Math.cos(armAngle)
  const armTipY = pivotHeight + longArmLength * Math.sin(armAngle)

  const projRelX = state.position[0] - armTipX
  const projRelY = state.position[1] - armTipY
  const distToArmTip = Math.sqrt(projRelX * projRelX + projRelY * projRelY)

  const slingAngle = Math.atan2(projRelY, projRelX)

  return { armTipX, armTipY, slingAngle, projRelX, projRelY, distToArmTip }
}

function detectPhase(
  state: PhysicsState17DOF,
  trebuchetProps: TrebuchetProperties,
  geometry: TrebuchetGeometry,
): TrebuchetPhase {
  const { position, velocity } = state
  const { slingLength, releaseAngle } = trebuchetProps
  const { distToArmTip, slingAngle } = geometry

  const onGround = position[1] <= 0.001 && velocity[1] <= 0

  if (onGround) {
    return TrebuchetPhase.PHASE_1_GROUND
  }

  if (distToArmTip > slingLength * 1.01 || slingAngle > releaseAngle) {
    return TrebuchetPhase.PHASE_3_RELEASED
  }

  return TrebuchetPhase.PHASE_2_SWINGING
}

export function computeDerivatives(
  state: PhysicsState17DOF,
  projectile: ProjectileProperties,
  trebuchetProps: TrebuchetProperties,
  normalForce: number,
): PhysicsDerivative17DOF {
  const geometry = computeGeometry(state, trebuchetProps)
  const phase = detectPhase(state, trebuchetProps, geometry)

  if (phase === TrebuchetPhase.PHASE_3_RELEASED) {
    return computeFreeFlight(state, projectile, trebuchetProps)
  }

  if (phase === TrebuchetPhase.PHASE_2_SWINGING) {
    return computeSwingingPhase(
      state,
      projectile,
      trebuchetProps,
      geometry,
      normalForce,
    )
  }

  return computeGroundPhase(
    state,
    projectile,
    trebuchetProps,
    geometry,
    normalForce,
  )
}

function computeFreeFlight(
  state: PhysicsState17DOF,
  projectile: ProjectileProperties,
  _trebuchetProps: TrebuchetProperties,
): PhysicsDerivative17DOF {
  const { velocity, windVelocity, position } = state
  const { mass } = projectile
  const altitude = position[1]

  const airVelocity = new Float64Array([
    velocity[0] - windVelocity[0],
    velocity[1] - windVelocity[1],
    velocity[2] - windVelocity[2],
  ])

  const spinVector = new Float64Array([0, 0, projectile.spin])
  const aero = aerodynamicForce(
    airVelocity,
    spinVector,
    projectile,
    altitude,
    288.15,
  )

  const ax = aero.total[0] / mass
  const ay = (aero.total[1] - mass * 9.81) / mass
  const az = aero.total[2] / mass

  return {
    position: new Float64Array([velocity[0], velocity[1], velocity[2]]),
    velocity: new Float64Array([ax, ay, az]),
    orientation: new Float64Array([0, 0, 0, 0]),
    angularVelocity: new Float64Array([0, 0, 0]),
    armAngle: 0,
    armAngularVelocity: 0,
    windVelocity: new Float64Array([0, 0, 0]),
    time: 1,
  }
}

function computeSwingingPhase(
  state: PhysicsState17DOF,
  projectile: ProjectileProperties,
  trebuchetProps: TrebuchetProperties,
  _geometry: TrebuchetGeometry,
  normalForce: number,
): PhysicsDerivative17DOF {
  const { armAngle, armAngularVelocity, velocity, windVelocity, position } =
    state
  const { mass } = projectile
  const {
    longArmLength,
    shortArmLength,
    counterweightMass,
    springConstant,
    dampingCoefficient,
    equilibriumAngle,
    jointFriction,
    flexuralStiffness,
    armMass,
  } = trebuchetProps

  const altitude = position[1]
  const airVelocity = new Float64Array([
    velocity[0] - windVelocity[0],
    velocity[1] - windVelocity[1],
    velocity[2] - windVelocity[2],
  ])
  const spinVector = new Float64Array([0, 0, projectile.spin])
  const aero = aerodynamicForce(
    airVelocity,
    spinVector,
    projectile,
    altitude,
    288.15,
  )

  const g = 9.81
  const L_a = longArmLength
  const L_cw = shortArmLength
  const m_p = mass
  const m_cw = counterweightMass
  const m_arm = armMass

  const I_arm = (1 / 3) * m_arm * L_a * L_a
  const I_cw = m_cw * L_cw * L_cw

  const springT = -springConstant * (armAngle - equilibriumAngle)
  const dampingT = -dampingCoefficient * armAngularVelocity
  const frictionT = -Math.sign(armAngularVelocity) * jointFriction * normalForce
  const flexuralT =
    -flexuralStiffness * Math.pow(armAngle - equilibriumAngle, 3)

  const theta = armAngle
  const theta_dot = armAngularVelocity

  const torque_counterweight = m_cw * g * L_cw * Math.cos(theta)
  const torque_arm = -(m_arm * g * (L_a / 2) * Math.cos(theta))
  const torque_projectile = -(m_p * g * L_a * Math.cos(theta))

  const torque_external = springT + dampingT + frictionT + flexuralT
  const torque_gravity = torque_counterweight + torque_arm + torque_projectile

  const I_total = I_arm + I_cw + m_p * L_a * L_a

  const theta_ddot = (torque_gravity + torque_external) / I_total

  const vx = -L_a * theta_dot * Math.sin(theta)
  const vy = L_a * theta_dot * Math.cos(theta)

  const ax =
    -L_a * theta_ddot * Math.sin(theta) -
    L_a * theta_dot ** 2 * Math.cos(theta) +
    aero.total[0] / m_p
  const ay =
    L_a * theta_ddot * Math.cos(theta) -
    L_a * theta_dot ** 2 * Math.sin(theta) -
    g +
    aero.total[1] / m_p

  return {
    position: new Float64Array([vx, vy, 0]),
    velocity: new Float64Array([ax, ay, 0]),
    orientation: new Float64Array([0, 0, 0, 0]),
    angularVelocity: new Float64Array([0, 0, 0]),
    armAngle: theta_dot,
    armAngularVelocity: theta_ddot,
    windVelocity: new Float64Array([0, 0, 0]),
    time: 1,
  }
}

function computeGroundPhase(
  state: PhysicsState17DOF,
  _projectile: ProjectileProperties,
  trebuchetProps: TrebuchetProperties,
  _geometry: TrebuchetGeometry,
  normalForce: number,
): PhysicsDerivative17DOF {
  const { armAngle, armAngularVelocity } = state
  const {
    longArmLength,
    shortArmLength,
    counterweightMass,
    springConstant,
    dampingCoefficient,
    equilibriumAngle,
    jointFriction,
    flexuralStiffness,
    armMass,
  } = trebuchetProps

  const g = 9.81
  const L_a = longArmLength
  const L_cw = shortArmLength
  const m_cw = counterweightMass
  const m_arm = armMass

  const I_arm = (1 / 3) * m_arm * L_a * L_a
  const I_cw = m_cw * L_cw * L_cw

  const springT = -springConstant * (armAngle - equilibriumAngle)
  const dampingT = -dampingCoefficient * armAngularVelocity
  const frictionT = -Math.sign(armAngularVelocity) * jointFriction * normalForce
  const flexuralT =
    -flexuralStiffness * Math.pow(armAngle - equilibriumAngle, 3)

  const theta = armAngle
  const theta_dot = armAngularVelocity
  const torque_counterweight = m_cw * g * L_cw * Math.cos(theta)
  const torque_arm = -(m_arm * g * (L_a / 2) * Math.cos(theta))

  const torque_external = springT + dampingT + frictionT + flexuralT
  const torque_gravity = torque_counterweight + torque_arm

  const I_total = I_arm + I_cw

  const theta_ddot = (torque_gravity + torque_external) / I_total

  const vx = -L_a * theta_dot * Math.sin(theta)
  const ax =
    -L_a * theta_ddot * Math.sin(theta) - L_a * theta_dot ** 2 * Math.cos(theta)

  return {
    position: new Float64Array([vx, 0, 0]),
    velocity: new Float64Array([ax, 0, 0]),
    orientation: new Float64Array([0, 0, 0, 0]),
    angularVelocity: new Float64Array([0, 0, 0]),
    armAngle: armAngularVelocity,
    armAngularVelocity: theta_ddot,
    windVelocity: new Float64Array([0, 0, 0]),
    time: 1,
  }
}
